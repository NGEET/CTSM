# -*- coding: utf-8 -*-
"""Verify_FATES-ELM_BCI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1053KTFZJWMSx6mGR1g97GOvn0WlruDEa

## Site Description 

The FATES-ELM simulations were designed to be representative of the Barro Colorado Nature Monument (BCNM), situated at Gatun Lake in the Panama canal.  Accordingly, measurements for the purpose of verification and calibration targets were selected within this site.  While there is variability within this site and any research site, we focus our simulation exercise on Barro Colorado Island (BCI) which contains the 50-hectare census inventory, as well as the Gigante Penninsula (GP) within which included measurement campaigns oriented around rooting and nutrient observations [Yavitt, Powers, etc].  The 50 hectare plot is sitated on Andesite with some volcanic Bohio and a small portion of marine Caimito facies [Baille et al.].


The verification of FATES nutrient enabled simulations at BCI focuses on both model states and fluxes, considering nitrogen and phosphorus masses.  Given that the nutrient cycle is coupled to the carbon cycle, we can also evaluate key carbon fluxes and states as indicators of the integrity of the overall simulation.  For instance, the amount of soil organic carbon is a result of decomposition and heterotrophic respiration rates.  In the current model hypothesis, nutrient immobilization limits these rates.


Note: In general, oxisols have low weatherable mineral content and low cation exchange capacity. 

---

## Soil Texture

From Yavitt and Wright 2001, soils at BCI were estimated at 25% Sand, 35% silt and 40% clay.



---

## Rooting Depths

From Odum 1970, the soils at BCNM are fairly shallow, with nearly all roots occupying the first half meter of soil.

| Source    | 50% Rooting Depth [m] | 95% Rooting Depth [m]| Maximum Rooting Depth [m] |
| :------   |           :---------: |        :-----------: | :-----------------:       |
| Odum 1970          | 0.11 | 0.57 |    |
| Wright et al. 1992 |      |      | \*0.375 |

\* Could be shrubs, mainland


---

## N and P Concentrations in Root Tissues

Fine root Nitrogen and Phosphorus concentrations come from control plot analysis from Wurzburger and Wright 2015.  Here they partitioned fine-roots into sub 1mm and 1-2mm root radii.

|         | Fine Roots < 1mm | Fine Roots 1 - 2 mm |
| ------- | ----------------| --------------------|
| C:N     | 28.1            | 40.2   |
| C:P     | 689.7|                  1012.76 |


---

## Measurements and Their Usage


The following is a list of verification targets:

| Observable | Source |
| :------- | :----------- |
| Total Soil C & N & P | Powers |
| Total fine-root biomass | Multiple authors  |



The following is a list of unused verification targets:

| Observable | Reason Unused |
| :------- | :----------- |
| Soil NH4 | High spatial and temporal variability (BOX PLOTS? Sensitivity on lowest HSAT COEFF?)|
| Soil NO3 | High spatial and temporal variability |
| Soil POx | High spatial and temporal variability |
| N & P immobilization rate | does not exist | 
| N & P mineralization rate | does not exist |
| nitrification rate | does not exist |
| denitrification rate | ? |


List of potential verification targets:

| Observable | Note |
| :------- | :----------- |
| Soil moisture | Important to nutrient leaching and uptake dynamics as well as plant leaf biophysics |






The following is a list of parameterization targets (input):

| Observable | Reason Unused |
| :------- | :-----------: |
| Tissue stoichiometry | Ely, etc | 
| Leaf N and P turnover reabsorption rate | ? |

--------

### Verification of fine-root biomass (carbon)
"""

# Load libraries

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib
import matplotlib.dates as mdates
from datetime import datetime, timedelta
import scipy.stats as st
import scipy.optimize as opt
import xarray as xr
import os
import gdown
from google.colab import files

!pip install netCDF4

print("xarray version: {} ".format(xr.__version__))

# Define some constants

cm2_per_m2 = 10000.0  # Square cm per square m
cm3_per_m3 = 1000000.0  # Cubic cm per cubic m
m3_per_cm3 = 1.e-6    # Cubic m per cubic cm
mg_per_g   = 1000.0   # milligrams per gram
g_per_kg   = 1000.0   # grams per kilogram
kg_per_g   = 1.e-3    # Duh
cm_per_m   = 100.0     

phos_amass = 30.974   # Atomic mass of elemental phosphorus
oxgn_amass = 15.999   # Atomic mass of elemental oxygen

# This is the elemental P mass fraction in phosphate
p_po4_frac = phos_amass/(phos_amass+4.0*oxgn_amass)

# Mean amount of necromass per live biomass from 
# Yavitt and Wright 2001
yw2001_necro_per_live = 0.0806


# Default font size for all plots

font = {'family' : 'normal',
        'weight' : 'normal',
        'size'   : 14}

matplotlib.rc('font', **font)

!(cd /content/;rm *)

# Download the root depth chemistry data prepared by Joe W
gdown.download('https://drive.google.com/uc?id=1R28kFbA6dRrZ8dB5w0xoxi23apKAJFz_', \
               '/content/Root_depth_chemistry.txt', \
               quiet=False)

# Download FATES model output
#gdown.download('https://drive.google.com/uc?id=1q8AGMJbiE5BA6ShnM4DvwijgOw_CixEI', \
#               '/content/model_output.nc', \
#               quiet=False)


#gdown.download('https://drive.google.com/uc?id=1yogM2XccxABGEL9szBy4NwdFnYE62m8M', \
#               '/content/model_output.nc', \
#               quiet=False)
#https://drive.google.com/file/d/17z69bm6sZm5YGCKUfOn12F_BkZdbaEKX/view?usp=sharing
# bcnp-v72-so1-nrl1-sf1xnpp-vc55-v2.5e7-api24-p2.nc

gdown.download('https://drive.google.com/uc?id=1_9xfRyJiQcmM95eFMKa1b05VlQzYcyYY', \
               '/content/model_output.nc', \
               quiet=False)
#gdown.download('https://drive.google.com/uc?id=17z69bm6sZm5YGCKUfOn12F_BkZdbaEKX', \
#               '/content/model_output.nc', \
 #              quiet=False)

# bci-cnp-1108-rdvm3e9-v10: 'https://drive.google.com/uc?id=1_Th9wp_Zzogn19MOFJZCpOlem7j0YCut'  
# bci-cnp-1108-rdvm525e9-v10-foc: 'https://drive.google.com/uc?id=1fxVC7ZqGu9Y0fOpIkpWXuUxwrT7Qc_el'
# bci-cnp-1108-rdvm3e9-v10-foc: 'https://drive.google.com/uc?id=1q8AGMJbiE5BA6ShnM4DvwijgOw_CixEI'

# Download FRED3 data that has been geospatialy selected to BCNM
gdown.download('https://drive.google.com/uc?id=1JMAjXfTKU6AQZac3EDe_zLuGAddDQmft', \
               '/content/FRED3_Filtered_Database_BCI.csv', \
               quiet=False)

# Download FATES ST3 run using inventory intialization, this is used
# to calibrate root mass

gdown.download('https://drive.google.com/uc?id=1N8N3kfTHASkZD4J1FysK_j8ICPu6UjNp', \
               '/content/rootprof_st3_bci.nc', \
               quiet=False)

# Load the ELM-FATES model output history files
# Assume that all time-stamps relevant to the anlayis
# are packed into one file. Use ncrcat for help.
# If multiple files exist, then they are assumed to 
# be ensemble members. It is assumed that if you
# provide a directory, then it is ensembles, if it is
# a single file, then ... duh
# 
# Necessary history output:
# SMIN_NH4_vr
# SMIN_NO3_vr
# SMINP_vr
#
# TOTSOMN... or.. SOIL1N_vr
# TOTSOMC
# TOTSOMP
# ============================================================= 
  
class time_info:
    def __init__(self,year,moy,dom,hod,dtime):
        self.year = year
        self.moy  = moy
        self.dom  = dom
        self.hod  = hod
        self.dtime = dtime  # Datetime object
    
def HistDateTranslator(histds):
    
    # This interprets the time-stamps and returns the mean
    # year, month, day and hour of day for each time interval
    
    year = []
    moy  = []
    dom  = []
    hod  = []
    dtimes = []
        
    print("number of dates: {}".format(len(histds.mcdate.data)))
    for i in range(len(histds.mcdate.data)):
    
        date_bounds = histds.time_bounds.data[i]
        yr0 = date_bounds[0].year
        mo0 = date_bounds[0].month
        dy0 = date_bounds[0].day
        hr0 = date_bounds[0].hour
        yr1 = date_bounds[1].year
        mo1 = date_bounds[1].month
        dy1 = date_bounds[1].day
        hr1 = date_bounds[1].hour
       
        dn0 = datetime(yr0,mo0,dy0,hr0)
        dn1 = datetime(yr1,mo1,dy1,hr1)
        dtime = datetime.fromtimestamp(0.5*(dn0.timestamp()+dn1.timestamp()))
    
        year.append(dtime.year)
        moy.append(dtime.month)
        dom.append(dtime.day)
        hod.append(dtime.hour)
        dtimes.append(dtime)

    return(year,moy,dom,hod,dtimes)
    
    
# Main call sequence for opening history output and time interpretation
# ======================================================================            

histfilestr = '/content/model_output.nc'


# This is a FATES output from an st3 run that should be coincident in time 
# with the field data and uses inventory for intialization

st3filestr = '/content/rootprof_st3_bci.nc'

st3ds=xr.open_dataset(st3filestr,engine='netcdf4' )
[year,month,day,hour,dtime] = HistDateTranslator(st3ds)
st3ds['year'] = xr.DataArray(data=year,dims=["time"])
st3ds['month'] = xr.DataArray(data=month,dims=["time"])
st3ds['day'] = xr.DataArray(data=day,dims=["time"])
st3ds['hour'] = xr.DataArray(data=hour,dims=["time"])
st3ds['time'] = dtime

#levgrnd0 = -100.0*st3ds['levsoi'].data
#print(st3ds['levgrnd'])



# Ensemble    
if os.path.isdir(histfilestr):
    histfilelist = [name for name in os.listdir('.') if os.path.isfile(name)]
    n = len(histfilelist)
    
else:
    histfilelist = [histfilestr]
    nfiles = 1
 


try:
  if(histds in dir()):
    print('clearing histds from memory')        
    del histds
except:
    print('no histds in memory')
try:
  if(histdss in dir()):
    print('clearing histdss from memory')        
    del histdss
except:
    print('no histdss in memory')

histdss = []
timing  = []

for histfile in histfilelist:
    histds = xr.open_dataset(histfile)
    levgrnd0 = -100.0*histds['levsoi'].data
    [year,month,day,hour,dtime] = HistDateTranslator(histds)
    timing.append(time_info(year,month,day,hour,dtime))
    #histds['year'] = year
    histds['month'] = xr.DataArray(data=month,dims=["time"])
    histds['day'] = xr.DataArray(data=day,dims=["time"])
    histds['hour'] = xr.DataArray(data=hour,dims=["time"])
    histds['time'] = dtime
    histds['year'] = xr.DataArray(data=year,dims=["time"])
    histdss.append(histds)

# Root Depth Chemistry
# -------------------------------------------------



# Had the following header info:
#"Experiment"	"Plot_ID"	"Depth"	"Coarse_root_mgcm3"	"Coarse_root_gm2"	"C_prcnt"	
# "N_prcnt"	"Pmg_g"	"Al_mg_g"	"Ca_mg_g"	"K_mg_g"	"Mg_mg_g"	"Mn_mg_g"	"Zn_mg_g"

rdc_data = pd.read_csv('/content/Root_depth_chemistry.txt', \
                      sep = "\t",
                      na_values = None )


#print(rdc_data["Depth"])
depth_u = []
depth_l = []
depth_m = []
biomass = []
croot_c2b = []
croot_nc = []
croot_pc = []


nrows = len(rdc_data["Depth"])

for i in range(nrows):

  # Parse Depth data
  str_splt = rdc_data.loc[i,"Depth"].split('-')
  ustr = str_splt[0]
  lstr = str_splt[1].split(' ')[0]
  depth_u.append(-float(ustr))
  depth_l.append(-float(lstr))
  depth_m.append(-np.mean([float(ustr),float(lstr)]))

  # Biomass
  if(rdc_data["Coarse_root_mgcm3"][i] == 'No_value'):
    biomass.append(np.nan)
  else: 
    biomass.append(float(rdc_data["Coarse_root_mgcm3"][i]))

  # C2B
  if(rdc_data["C_prcnt"][i] == 'No_value'):
    croot_c2b.append(np.nan)
  else: 
    croot_c2b.append(100./float(rdc_data["C_prcnt"][i]))


  # N/C Ratio [g/g]
  if(rdc_data["N_prcnt"][i] == 'No_value'):
    croot_nc.append(np.nan)
  else: 
    croot_nc.append(float(rdc_data["N_prcnt"][i])/float(rdc_data["C_prcnt"][i]))

  # P/C Ratio [g/g]
  if(rdc_data["Pmg_g"][i] == 'No_value'):
    croot_pc.append(np.nan)
  else: 
    croot_pc.append(100.*0.001*float(rdc_data["Pmg_g"][i])/float(rdc_data["C_prcnt"][i]))


# Fit an exponential to the biomass data, use this fit to come up with integrated
# mass quantities to help with stoichiometries
# biomass = a*e^(b*depth)
# log(biomass) = loga + b*depth
# biomass = e^(loga)* e^(b*depth)

#false_zero = 1.e-20
#biomass = np.where(np.array(biomass)<false_zero, false_zero, biomass)

biomass = np.array(biomass)
croot_c2b = np.array(croot_c2b)
depth_m = np.array(depth_m)
croot_nc = np.array(croot_nc)
croot_pc = np.array(croot_pc)

fit_biomass = biomass[biomass>0.0]
fit_croot_c2b = croot_c2b[croot_c2b>0.0]
fit_croot_nc = croot_nc[croot_nc>0.0]
fit_croot_pc = croot_pc[croot_pc>0.0]

[bb,loga] = np.polyfit(depth_m[biomass>0.0], np.log(fit_biomass), 1, w=np.sqrt(fit_biomass))
ba = np.exp(loga)

[cb,ca] = np.polyfit(depth_m[croot_c2b>0.0], fit_croot_c2b, 1)
[nb,na] = np.polyfit(depth_m[croot_nc>0.0], fit_croot_nc, 1)
[pb,pa] = np.polyfit(depth_m[croot_pc>0.0], fit_croot_pc, 1)

# Integrate over the profile to determine the mean C2B, N:C and P:C
lin_depth = np.linspace(0,-100,1000)

weights = ba*np.exp(bb*lin_depth)/np.sum(ba*np.exp(bb*lin_depth))

mean_c2b = np.sum((ca+cb*lin_depth)*weights)
mean_nc = np.sum((na+nb*lin_depth)*weights)
mean_pc = np.sum((pa+pb*lin_depth)*weights)


print(mean_c2b,mean_nc,mean_pc)

fig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(2,2,figsize=(8,7))

p1=ax1.get_position()
p2=ax2.get_position()
p3=ax3.get_position()
p4=ax4.get_position()

#x0=0.02;xb=0.01;dx=0.3
#ax1.set_position([x0,p1.y0,dx,0.8])
#ax2.set_position([x0+xb+dx,p1.y0,dx,0.8])
#ax3.set_position([x0+2*(xb+dx),p1.y0,dx,0.8])

lin_depth = np.linspace(0,-75,100)

ax1.scatter(biomass,depth_m,s=50,marker='o')
ax1.plot(ba*np.exp(bb*lin_depth),lin_depth)
ax1.set_ylabel('Soil Depth [cm]')
ax1.set_xlabel('')
ax1.set_title('Biomass [mg/cm3]')

ax2.scatter(croot_c2b,depth_m,s=50,marker='o')
ax2.plot(ca+cb*lin_depth,lin_depth)
ax2.set_ylabel('')
ax2.set_yticklabels('')
ax2.set_xlabel('')
ax2.set_title('C2B')
ax2.axvline(x=2.0,color='k')
ax2.set_xlim(left=0)


ax3.scatter(croot_nc,depth_m,s=50,marker='o')
ax3.plot(na+nb*lin_depth,lin_depth)
ax3.set_ylabel('Soil Depth [cm]')
ax3.set_title('N Concentration [gN/gC]')



# NOTE: Need to check in with Joe about the type of roots sampled here. ie
# does this include sampling of below-ground bole, or large conduits, or are
# these of a thinner gauge.

for ds in histdss:
    #ds0111 = ds.where( (ds['time.year'] > 2000) & (ds['time.year'] < 2002), drop=True)
    ds0111 = ds.where( (ds['year'] > 2000) & (ds['year'] < 2002), drop=True)
    sapwnc = ds0111['FATES_SAPWOODN'].mean(axis=0).isel(lndgrid=0) / ds0111['FATES_SAPWOODC'].mean(axis=0).isel(lndgrid=0)

    # Or if we include structural tissues
    totn = ds0111['FATES_VEGN'].mean(axis=0).isel(lndgrid=0)-(ds0111['FATES_LEAFN'].mean(axis=0).isel(lndgrid=0)+ds0111['FATES_FROOTN'].mean(axis=0).isel(lndgrid=0)+ds0111['FATES_REPRON'].mean(axis=0).isel(lndgrid=0))
    totc = ds0111['FATES_VEGC'].mean(axis=0).isel(lndgrid=0)-(ds0111['FATES_LEAFC'].mean(axis=0).isel(lndgrid=0)+ds0111['FATES_FROOTC'].mean(axis=0).isel(lndgrid=0)+ds0111['FATES_REPROC'].mean(axis=0).isel(lndgrid=0))

    ax3.axvline(x=np.mean(totn/totc),label='elm-fates',color='k')

ax3.set_xlim(left=0)

ax4.scatter(1000*croot_pc,depth_m,s=50,marker='o')
ax4.plot(1000*(pa+pb*lin_depth),lin_depth)

ax4.set_ylabel('')
ax4.set_yticklabels('')
ax4.set_xlabel('')
ax4.set_title('P Concentration [mgP/gC]')

for ds in histdss:
    ds0111 = ds.where( (ds['year'] > 2000) & (ds['year'] < 2002), drop=True)
    sapwpc = 1000.0*ds0111['FATES_SAPWOODP'].mean(axis=0).isel(lndgrid=0)/ds0111['FATES_SAPWOODC'].mean(axis=0).isel(lndgrid=0)
    # Or if we include structural tissues
    totp = ds0111['FATES_VEGP'].mean(axis=0).isel(lndgrid=0)-(ds0111['FATES_LEAFP'].mean(axis=0).isel(lndgrid=0)+ds0111['FATES_FROOTP'].mean(axis=0).isel(lndgrid=0)+ds0111['FATES_REPROP'].mean(axis=0).isel(lndgrid=0))
    totc = ds0111['FATES_VEGC'].mean(axis=0).isel(lndgrid=0)-(ds0111['FATES_LEAFC'].mean(axis=0).isel(lndgrid=0)+ds0111['FATES_FROOTC'].mean(axis=0).isel(lndgrid=0)+ds0111['FATES_REPROC'].mean(axis=0).isel(lndgrid=0))
    
    ax4.axvline(x=1000*np.mean(totp/totc),label='elm-fates',color='k')

ax4.set_xlim(left=0)

ax1.grid("on");ax2.grid("on");ax3.grid("on");ax4.grid("on")

fig.show()

"""## Mean Coarse Root Stoichiometries

We fit and exponential curve to the root biomass data. Linear fits are applied to carbon to biomass, and the nitrogen and phosphorus stoichiometry measurements.  The three are integrated over depth, using the normalized root biomass as weights. The following table describes these mean C, N and P stoichiometries for coarse root data:

| C2B | N:C | P:C |
|:------:|:---------:|:-----------: |
|2.56 | 0.0247 | 0.000684  |


"""

# Load FRED3 data
# ============================================================


fred3_bcnm_file = "/content/FRED3_Filtered_Database_BCI.csv"

# Load the csv spreadsheet, keep only the code and the data
f3_data = pd.read_csv(fred3_bcnm_file, \
                      skiprows  = [0,2,3,4,5,6,7,8,9,10], \
                      na_values = None )

# Open data for just the column-count row, which will help us
# filter out data that is not there (BCNM IS COMPLETE THOUGH)
# cc_row = 9
# num_lines = sum(1 for line in open(fred3_bcnm_file))
# print(num_lines)
# to_exclude = [i for i in range(num_lines) if i not in [cc_row] ]
# count_data = pd.read_csv(fred3_bcnm_file, skiprows = to_exclude )


# Force various fields to their desired types
# Note:  Unspecified fields will be converted to NaN
#       for floats is this the special value, for
#       strings, its actually "nan"

f3_data = f3_data.astype({"F00003": str})        # Author
f3_data = f3_data.astype({"F00055": str})        # Belowground part FR/CR/FR+CR/TR
f3_data = f3_data.astype({"F00962": str})        # Sampled to max depth? yes/no
f3_data = f3_data.astype({"F00064": str})        # Living or dead? living/dead
f3_data = f3_data.astype({"F01159": str})        # Notes on treatment type control/etc

f3_data = f3_data.astype({"F00068": "float64"})  # Upper sample depth [cm]
f3_data = f3_data.astype({"F00069": "float64"})  # Lower sample depth [cm]
f3_data = f3_data.astype({"F00954": "float64"})  # Depth which includes all roots [cm]
f3_data = f3_data.astype({"F00885": "float64"})  # Belowground biomass per ground area
f3_data = f3_data.astype({"F00887": "float64"})  # SE Belowground biomass per ground area
f3_data = f3_data.astype({"F00949": "float64"})  # Root diameter class lower bound [mm]
f3_data = f3_data.astype({"F00950": "float64"})  # Root diameter class upper bound [mm]
f3_data = f3_data.astype({"F00995": "float64"})  # Soil C content [mg/g] (Powers+ only )
f3_data = f3_data.astype({"F01009": "float64"})  # Soil C/N ratio (Powers+ only)
f3_data = f3_data.astype({"F01018": "float64"})  # Soil P content (Powers+ only)
f3_data = f3_data.astype({"F01080": "float64"})
f3_data = f3_data.astype({"F01076": "float64"})  # Soil N_Exchangeable NH4+ Mass [mg/kg]
f3_data = f3_data.astype({"F01077": "float64"})  # SE Soil N_Exchangeable NH4+ Mass [mg/kg]
f3_data = f3_data.astype({"F01078": "float64"})  # Soil N_Exchangeable NO3+ Mass [mg/kg]
f3_data = f3_data.astype({"F01079": "float64"})  # SE Soil N_Exchangeable NO3+ Mass [mg/kg]
f3_data = f3_data.astype({"F01080": "float64"})  # Soil P_Exchangeable PO43- Mass [mg/kg]
f3_data = f3_data.astype({"F01081": "float64"})  # SE Soil N_Exchangeable PO43- Mass [mg/kg]
f3_data = f3_data.astype({"F00991": "float64"})  # Bulk density [g/cm3]


# Number of observations at the site
nobs = len(f3_data["F00003"])

# Number of studies
nstudy = 8

# First, lets filter our data for each study and make sure we
# every observation gets classified somewhere

y2011_ids = []; 
w2011_ids = [];
yw2001_ids = []
ww2015_ids = []
p2005_ids = []
o1970_ids = []
c1999_ids = []
w1992_ids = []

# Give the different studies different array indices
w2011=0
y2011=1
yw2001=2
ww2015=3
p2005=4
o1970=5
c1999=6
w1992=7

study_colors = np.random.rand(nstudy)
study_leg = ["w2011","y2011","yw2001","ww2015","p2005","o1970","c1999","w1992"]
study_loc = [1,1,0,1,0,3,3,3]  # 0=BCI ,  1=GP
study_map = []
study_id  = []
for i in range(nobs):
    if 'Wright et al 2011' == f3_data.loc[i,"F00003"].strip():
        w2011_ids.append(i)
        study_id.append(0)
    elif 'Yavitt et al 2011' == f3_data.loc[i,"F00003"].strip():
        y2011_ids.append(i)
        study_id.append(1)
    elif 'Yavitt and Wright 2001' == f3_data.loc[i,"F00003"].strip():
        yw2001_ids.append(i)
        study_id.append(2)
    elif 'Wurzburger and Wright 2015' == f3_data.loc[i,"F00003"].strip():
        ww2015_ids.append(i)
        study_id.append(3)
    elif 'Powers et al 2005' == f3_data.loc[i,"F00003"].strip():
        p2005_ids.append(i)
        study_id.append(4)
    elif 'Odum 1970' == f3_data.loc[i,"F00003"].strip():
        o1970_ids.append(i)
        study_id.append(5)
    elif 'Cavelier et al 1999' == f3_data.loc[i,"F00003"].strip():
        c1999_ids.append(i)
        study_id.append(6)
    elif 'Wright et al 1992' == f3_data.loc[i,"F00003"].strip():
        w1992_ids.append(i)
        study_id.append(7)
    else:
        print('Unclassified measurement ref')

study_map.append(w2011_ids)
study_map.append(y2011_ids)
study_map.append(yw2001_ids)
study_map.append(ww2015_ids)
study_map.append(p2005_ids)
study_map.append(o1970_ids)
study_map.append(c1999_ids)
study_map.append(w1992_ids)
        
        
# Perform the checks
if(nobs != len(y2011_ids)+len(w2011_ids)+len(yw2001_ids)+ \
   len(ww2015_ids)+len(p2005_ids)+len(o1970_ids)+ \
   len(c1999_ids)+len(w1992_ids) ):
    print("missing classifications")

# Print out total measurements
prt_str = "Total obs at BCNM: {}\n".format(nobs) + \
    "Y2011: {}\n".format(len(y2011_ids)) + \
    "W2011: {}\n".format(len(w2011_ids)) + \
    "YW2001: {}\n".format(len(yw2001_ids)) + \
    "WW2015: {}\n".format(len(ww2015_ids)) + \
    "P2005: {}\n".format(len(p2005_ids)) + \
    "O1970: {}\n".format(len(o1970_ids)) + \
    "C1999: {}\n".format(len(c1999_ids)) + \
    "W1992: {}".format(len(w1992_ids))


    
# Typical filters

# From F00055: 
# "Plant parts included in row data. CR = coarse roots (roots with diameter greater
# than 2 mm), FR = fine roots (roots with diameter less than 2 mm), R = rhizomes, 
# BS = belowground stems, TR = total root system, and TB = total belowground system. 
# “TR” is used when all plant roots are considered but the source does not specify whether 
# or not coarse roots are present. “TB” is used when all belowground plant mass is 
# considered but the source does not name all the plant parts comprised therein. 
# Note that the FR category may contain roots measured from all roots from 0 to 2 mm in 
# diameter, or may contain more restricted measures, e.g. 0 to 1 mm. The specific ranges 
# of diameters included or allowed for a given sample are reported as the upper and lower 
# bounds for root diameter classes in F00949 and F00950, respectively.


# Soil depths, uppper and lower edges (convert to neg format)
upper_depth = -f3_data["F00068"]
lower_depth = -f3_data["F00069"]
mean_depth = 0.5*(lower_depth+upper_depth)

# Belowground biomass per ground area F00885
# Standard error accompanying: F00887
# ------------------------------------------------------------------

# Correct bgb YW2001 (data is g/cm3)
# Check for consistency in depth data and bgb data
for i in study_map[yw2001]:
    cm3_per_layer = cm2_per_m2*(upper_depth[i]-lower_depth[i])
    # If depth data is available
    if(not np.isnan(f3_data["F00885"][i])):
        f3_data.loc[i,"F00885"] = f3_data.loc[i,"F00885"]*cm3_per_layer
    if(not np.isnan(f3_data["F00887"][i])):
        f3_data.loc[i,"F00887"] = f3_data.loc[i,"F00887"]*cm3_per_layer

# Wurzburger and Wright split fine-roots into 0-1mm, 1-2mm, and 0-2mm
# It comes out to only thee different measurements for the control plot
# but for calculating total fineroot biomass we will remove the partials
for i in study_map[ww2015]:
    if (not(np.abs(f3_data["F00949"][i]-0.0)<0.1 and np.abs(f3_data["F00950"][i]-2.0)<0.1)):
        f3_data.loc[i,"F00885"] = np.nan
        f3_data.loc[i,"F00887"] = np.nan

#f3_data = f3_data.astype({"F00055": str})        # Belowground part FR/CR/FR+CR/TR
#f3_data = f3_data.astype({"F00962": str})        # Sampled to max depth? yes/no
#f3_data = f3_data.astype({"F00064": str})        # Living or dead? living/dead            

for j in range(nstudy):
    for i in study_map[j]:
        # Filter if biomass value is there
        if (not np.isnan(f3_data.loc[i,'F00885'])):
            # Filter in only fine roots
            if (f3_data["F00055"][i].strip() == "FR"):
                # Allow any of living, both or unspecified (just remove dead...)
                if (f3_data["F00064"][i].strip() in ["living","both","unspecified"]): 
                    if (f3_data["F00064"][i].strip() in ["both"]):
                        f3_data.loc[i,"F00885"] = f3_data.loc[i,"F00885"]/(yw2001_necro_per_live+1.0)
                        f3_data.loc[i,"F00887"] = f3_data.loc[i,"F00887"]/(yw2001_necro_per_live+1.0)

# ------------------------------------------------------------------------------        
# Fine root biomass evaluation over depth
# ------------------------------------------------------------------------------

fr_biomass_fit = []
fr_depth_fit  = []

fig, ax = plt.subplots()
for j in range(nstudy):
 
  # Y2011 needs corrections, just use these manually corrected values ...
  if (j==y2011):
    fr_depth = [-2.5,-7.5,-12.5,-17.5]
    cm3_per_m2 = 5.0*10000.0/1000.0
    fr_biomass = [152.0/cm3_per_m2,74.789/cm3_per_m2, \
                    38.63/cm3_per_m2,37.38/cm3_per_m2]
    fr_biomass_se = [np.nan,np.nan,np.nan,np.nan]
  
    for ii in range(len(fr_depth)):
      fr_biomass_fit.append(fr_biomass[ii])
      fr_depth_fit.append(fr_depth[ii])
  else: 

    fr_depth = []
    fr_biomass = []
    fr_biomass_se = []

    for i in study_map[j]:

      # Filter if biomass value is there
      if (not np.isnan(f3_data.loc[i,'F00885']) ):

        # Filter in if depths are available
        cm3_per_m2 = (upper_depth[i]-lower_depth[i])*cm2_per_m2

        if (not np.isnan(cm3_per_m2)):
          # Filter in only fine rootsa
          if (f3_data["F00055"][i].strip() == "FR"):
            # Allow any of living, both or unspecified (just remove dead...)
              #living/dead/both/unspecified
            if (f3_data["F00064"][i].strip() in ["living","both"]): #,"unspecified"]):
              # Dont include any treatments. Assume unlabled is a control                            
              if ((f3_data["F01159"][i].strip().lower() == "control") or \
                  (f3_data["F01159"][i].strip() == "nan") ):
                fr_depth.append(mean_depth[i])
                fr_biomass.append(1000*f3_data["F00885"][i]/cm3_per_m2)
                fr_biomass_se.append(1000*f3_data["F00887"][i]/cm3_per_m2)
                            
                            
                        
  if (len(fr_depth)>0):

    for ii in range(len(fr_depth)):
      fr_biomass_fit.append(fr_biomass[ii])
      fr_depth_fit.append(fr_depth[ii])

    if (study_loc[j]==0):
      ax.scatter(fr_biomass,fr_depth,label=study_leg[j],s=50,marker='o')            
      ax.errorbar(fr_biomass,fr_depth,xerr=fr_biomass_se,fmt="o")
    elif (study_loc[j]==1):
      ax.scatter(fr_biomass,fr_depth,label=study_leg[j],s=50,marker='^')
      ax.errorbar(fr_biomass,fr_depth,xerr=fr_biomass_se,fmt="^")
    else:
      ax.scatter(fr_biomass,fr_depth,label=study_leg[j],s=50,marker='*')
      ax.errorbar(fr_biomass,fr_depth,xerr=fr_biomass_se,fmt="*")
            
ax.set_xscale('log')






# Get a fit of the fine-root attenuation profile
#
fr_depth_fit = np.array(fr_depth_fit)
fr_biomass_fit = np.array(fr_biomass_fit)
fr_depth_fit = fr_depth_fit[fr_biomass_fit>0.0]
fr_biomass_fit = fr_biomass_fit[fr_biomass_fit>0.0]

def RootFrac2P(z,a,b):

  frac = np.exp(a*z) + np.exp(b*z)
  return(frac)

#popt, pcov = curve_fit(RootFrac2P, fr_depth_fit, fr_biomass_fit)

[frb,frloga] = np.polyfit(fr_depth_fit, np.log(fr_biomass_fit), 1, w=np.sqrt(fr_biomass_fit))
fra = np.exp(frloga)

lin_depth = np.linspace(0,-75,100)

##ax.plot(fra*np.exp(frb*lin_depth),lin_depth)

#ax.plot(np.exp(a*z) + np.exp(b*z),lin_depth)



# biomass_z = a*e^(b*z)
# biomass_t = int(a*e^(b*z))_0^inf
# biomass_t = (a/b)*exp(b*z)


# Total roots?
#fr_biomass_tot = (fra/frb)*np.exp(bb*-100.0) - (ba/bb)*np.exp(bb*0)

#print(fra,frb)
#print(fr_depth_fit)
#print((fra/frb)*np.exp(frb*0))
#print((fra/frb)*np.exp(frb*-100.0))

# Look at fine-root biomass in either the test simulation output, or an ST3 
# model

for ds in histdss:
    ds0111 = ds.where( (ds['year'] > 2000) & (ds['year'] < 2012), drop=True)
    levgrnd1 = -cm_per_m*ds['levsoi'].data
    ax.scatter(1.e6*m3_per_cm3*ds0111['FATES_FROOTC_SL'].mean(dim='time').data,levgrnd1,label='elm-fates',s=50,marker='+',color=[0.1,0.1,0.1])

    

    
plt.legend(loc="lower right")
ax.set_xscale('log')
ax.set_xlabel('Fine Root Biomass [mg/cm3]')            
ax.set_ylabel('Depth [cm]')    
ax.set_xlim([0.05,3.5])
ax.set_ylim([-75,0])
ax.grid("on")

plt.tight_layout()
plt.show()
#plt.savefig('fnrt_prof_comp.png')
#files.download('fnrt_prof_comp.png')


aa = 1.
bb = 7.
lin_depth = np.linspace(0,-75,100)
frac_prof = np.exp(0.01*aa*lin_depth)+np.exp(0.01*bb*lin_depth)

#  log(frac_prof) = log(e^(a*z)+e^(b*z)) = log

#print(frac_prof)
#ax.plot(frac_prof,lin_depth)

"""Figure 1. Fine root biomass as a function of depth at from several studies at BCNM. All data was filtered to report only estimates of roots from 0-2 mm diameter. Studies that did not differentiate between live and dead roots were corrected using the necromass to livemass ratio of 0.0806 in Yavitt and Wright 2001. Sites with circles are at BCI, sites with triangles are at GP."""

# Soil Bulk Density Profile and Variability over depth at BCI
# This is only available in Yavitt and Wright 2001
# Yavitt and Wright reported bulk densities on Alfisols
# but Powers et al 2004 worked on Oxisols as well as Alfisols

# They do have control, water manipulation, 
bd = []
bd_depth = []
for i in study_map[yw2001]:
    if(not np.isnan(f3_data["F00991"][i])):
        if(f3_data["F01159"][i].strip().lower() == 'control'):

            bd.append(f3_data["F00991"][i])
            bd_depth.append(mean_depth[i])

            
#p_opt, _ = opt.curve_fit(linear,bd,bd_depth)            

(bd_slope,bd_int,_,_,_) = st.linregress(np.array(bd_depth),np.array(bd))

bd_deptha = np.min(bd_depth)
bd_depthz = np.max(bd_depth)
bda = bd_int + bd_slope*bd_deptha
bdz = bd_int + bd_slope*bd_depthz

mean_bd = np.mean(bd)
            
fig,ax = plt.subplots(1,1,figsize=(6,5))

ax.scatter(bd,bd_depth,s=50,marker='o')
ax.plot([bda,bdz],[bd_deptha,bd_depthz],color='k')
ax.set_ylabel('Soil Depth [cm]')
ax.set_xlabel('Soil Bulk Density [g/cm3]')
ax.grid("on")

# Total Nitrogen and Phosphorus (Powers+2005)  September-October 2001
# F00995  Soil C content [mg/g] (Powers+ only ) Soil C per soil dry mass
# F01009  Soil C/N ratio (Powers+ only)
# F01018  Soil P content [mg/g] (Powers+ only)
# ------------------------------------------------------------------
totc_depth = []
totc = []
totn_depth = []
totn = []
totp_depth = []
totp = []

for i in study_map[p2005]:
    
    # Total carbon [mg/cm3] = [mg/g]*[g/cm3] per dry soil mass
    if( not np.isnan(f3_data.loc[i,'F00995'])):
    
        totc_depth.append(mean_depth[i])
        totc.append(f3_data.loc[i,'F00995']*mean_bd)
    
    # Total nitrogen [mg/cm3] = [mg/g]*[g/cm3] per dry soil mass
    if( not np.isnan(f3_data.loc[i,'F01009'])):

        totn_depth.append(mean_depth[i])
        totn.append(f3_data.loc[i,'F00995']*mean_bd/f3_data.loc[i,'F01009'])
        #totn.append(1.0/f3_data.loc[i,'F01009'])
        
    # Total phosphorus [mg/cm3] = [mg/g]*[g/cm3] per dry soil mass
    if( not np.isnan(f3_data.loc[i,'F01018'])):

        totp_depth.append(mean_depth[i])
        totp.append(f3_data.loc[i,'F01018']*mean_bd)        
    

    #st.t.interval(0.95, len(a)-1, loc=np.mean(a), scale=st.sem(a))
    
    
# Calculate mean and 95% Conf intervals at depth

 
    
fig, (ax1,ax2,ax3) = plt.subplots(1,3,figsize=(11,4.5))

p1=ax1.get_position()
p2=ax2.get_position()
p3=ax3.get_position()

x0=0.02;xb=0.04;dx=0.3
ax1.set_position([x0,p1.y0,dx,0.8])
ax2.set_position([x0+xb+dx,p1.y0,dx,0.8])
ax3.set_position([x0+2*(xb+dx),p1.y0,dx,0.8])

ax1.scatter(totc,totc_depth,s=50,marker='o')

# Look for the SOMC over the following interval: 2001 to match Powers
# SOIL1C_vr: [mg/cm3] = [gC/m^3] * [m3/cm3] * [mg/g]

for ds in histdss:
    ds0111 = ds.where( (histds['time.year'] > 2000) & (histds['time.year'] < 2002), drop=True)
    total_c = ds0111['SOIL1C_vr'].mean(axis=0).isel(lndgrid=0) + \
        ds0111['SOIL2C_vr'].mean(axis=0).isel(lndgrid=0) + \
        ds0111['SOIL3C_vr'].mean(axis=0).isel(lndgrid=0)
    ax1.scatter(1000.0*m3_per_cm3*total_c,levgrnd0,label='elm-fates',s=50,marker='+')

ax1.set_ylabel('Soil Depth [cm]')
ax1.set_xlabel('Organic Soil Carbon \nContent [mg/cm3]')
ax1.set_ylim([1.1*np.min(totc_depth),0.0])
ax1.set_xscale('log')    
ax1.set_xlim([1.e0,1.e2])    
ax1.legend(['Powers2005','elm-fates'])

ax2.scatter(totn,totn_depth,s=50,marker='o')
for ds in histdss:
    ds0111 = ds.where( (histds['time.year'] > 2000) & (histds['time.year'] < 2002), drop=True)
    total_n = ds0111['SOIL1N_vr'].mean(axis=0).isel(lndgrid=0) + \
        ds0111['SOIL2N_vr'].mean(axis=0).isel(lndgrid=0) + \
        ds0111['SOIL3N_vr'].mean(axis=0).isel(lndgrid=0)
    ax2.scatter(1000.0*m3_per_cm3*total_n,-cm_per_m*ds0111['levgrnd'],label='elm-fates',s=50,marker='+')
ax2.set_xlabel('Organic Soil Nitrogen \nContent [mg/cm3]')
ax2.set_yticklabels([])
ax2.set_ylim([1.1*np.min(totc_depth),0.0])
ax2.set_xscale('log')    
ax2.set_xlim([1.e-1,1.e1])

ax3.scatter(totp,totp_depth,s=50,marker='o')
for ds in histdss:
    ds0111 = ds.where( (histds['time.year'] > 2000) & (histds['time.year'] < 2002), drop=True)
    total_p = ds0111['SOIL1P_vr'].mean(axis=0).isel(lndgrid=0) + \
        ds0111['SOIL2P_vr'].mean(axis=0).isel(lndgrid=0) + \
        ds0111['SOIL3P_vr'].mean(axis=0).isel(lndgrid=0) + \
        ds0111['OCCLP_vr'].mean(axis=0).isel(lndgrid=0) + \
        ds0111['PRIMP_vr'].mean(axis=0).isel(lndgrid=0) + \
        ds0111['SECONDP_vr'].mean(axis=0).isel(lndgrid=0)
    
ax3.scatter(1000.0*m3_per_cm3*total_p,-cm_per_m*ds0111['levsoi'],label='elm-fates',s=50,marker='+')
ax3.set_xlabel('Total Soil Phosphorus \nContent [mg/cm3]')
ax3.set_ylim([1.1*np.min(totc_depth),0.0])
ax3.set_yticklabels([])
ax3.set_xscale('log')    
ax3.set_xlim([1.e-2,1.e1])    

ax1.grid("on");ax2.grid("on");ax3.grid("on");

plt.savefig('organic_cnp_compare.png')

files.download('organic_cnp_compare.png')

"""Total carbon and nutrient content from Powers et al. 2004. Measurements taken at BCI during the end of the wet season, September-October 2001. These are measurements of nutrients bound in organic matter, including fungal hyphae, bacteria and soluble solutions; with roots and debris removed from the samples. Total Nitrogen and Carbon were measured via dry combustion. Total Phosphorus determined by first digesting with HNO3 and then measuring with inductively coupled plasma electron spectroscopy. Mineralized and labile pools are expected to volatalize during the drying process."""

# Evaluation of mineralized nutrients
# F01076: Soil N_Exchangeable NH4+ Mass [mg/kg]
# F01077: SE Soil N_Exchangeable NH4+ Mass [mg/kg]
# F01078: Soil N_Exchangeable NO3+ Mass [mg/kg]
# F01079: SE Soil N_Exchangeable NO3+ Mass [mg/kg]
# F01080: Soil P_Exchangeable PO43- Mass [mg/kg]
# F01081: SE Soil N_Exchangeable PO43- Mass [mg/kg]

nh4 = []; no3 = []; po4 = []
nh4_depth = []; no3_depth=[]; po4_depth = []

#bd,bd_depth  [g/cm3]

for i in range(nobs):
    
    # Ignore all treatment type plots, only control or NA
    if((f3_data["F01159"][i].strip().lower() == "control") or \
        (f3_data["F01159"][i].strip() == "nan") ):
    
        # See if the NH4 data is there
        if(not np.isnan(f3_data["F01076"][i]) and \
            not np.isnan(f3_data["F00991"][i]) and \
              not np.isnan(mean_depth[i])):            
            
            # [mg/kg] / ([g/cm3]/[g/kg]) = [mg/cm3]
            nh4.append( f3_data["F01076"][i]*kg_per_g/f3_data["F00991"][i])
            nh4_depth.append(mean_depth[i])
        
        # See if the NO3 data is there
        if(not np.isnan(f3_data["F01078"][i]) and \
            not np.isnan(f3_data["F00991"][i]) and \
              not np.isnan(mean_depth[i])):   
                
            # [mg/kg] / ([g/cm3]/[g/kg]) = [mg/cm3]
            no3.append( f3_data["F01078"][i]*kg_per_g/f3_data["F00991"][i])
            no3_depth.append(mean_depth[i])
        
        # See if the PO4 data is there
        if(not np.isnan(f3_data["F01080"][i]) and \
            not np.isnan(f3_data["F00991"][i]) and \
              not np.isnan(mean_depth[i])):
                
            # [mg/kg] / ([g/cm3]/[g/kg]) = [mg/cm3]
            po4.append( f3_data["F01080"][i]*kg_per_g/f3_data["F00991"][i])
            po4_depth.append(mean_depth[i])        
        


        
fig, (ax1,ax2,ax3) = plt.subplots(1,3,figsize=(11,4.5))

p1=ax1.get_position()
p2=ax2.get_position()
p3=ax3.get_position()

x0=0.02;xb=0.01;dx=0.3
ax1.set_position([x0,p1.y0,dx,0.8])
ax2.set_position([x0+xb+dx,p1.y0,dx,0.8])
ax3.set_position([x0+2*(xb+dx),p1.y0,dx,0.8])

false_zero = 1e-14



ax1.scatter(nh4,nh4_depth,s=50,marker='o')
nh4 = np.where(np.array(nh4) < 1e-20, false_zero, nh4)
min_nh4  = np.min(nh4);max_nh4  = np.max(nh4)
for ds in histdss:
    ds0111 = ds.where( (histds['year'] > 2000) & (histds['year'] < 2002), drop=True)

    #mod_depth = -cm_per_m*ds0111['levsoi'].values
    mod_depth    = levgrnd0
    modnh4       = mg_per_g*ds0111['SMIN_NH4_vr'].mean(axis=0).values*m3_per_cm3
    modnh4       = modnh4[mod_depth>=np.min(nh4_depth)]
    modnh4_depth = mod_depth[mod_depth>=np.min(nh4_depth)]
    modnh4 = np.where(modnh4 < 1e-20, false_zero, modnh4)

    print('NH4_DEPTH: {}'.format(np.min(nh4_depth)))    
    print('MOD DEPTHS: {}'.format(mod_depth))
    print('FILT DEPTHS: {}'.format(modnh4_depth))
    min_nh4 = np.min([min_nh4,np.min(modnh4)])
    max_nh4 = np.max([max_nh4,np.max(modnh4)])
    ax1.scatter(modnh4,modnh4_depth,label='elm-fates',s=50,marker='+')

ax1.set_ylabel('Soil Depth [cm]')
ax1.set_xlabel('NH4+ Content [mg/cm3]')
ax1.set_ylim([1.1*np.min(nh4_depth),0.0])
if (np.min(nh4)>1.e-20):
    ax1.set_xscale('log')
    ax1.set_xlim([0.01*min_nh4,10*max_nh4])
else:
    ax1.set_xlim([0,ax1.get_xlim()[1]]) 

    
ax1.legend(['field','model'])    

ax2.scatter(no3,no3_depth,s=50,marker='o')
no3 = np.where(np.array(no3) < 1e-20, false_zero, no3)
min_no3  = np.min(no3);max_no3  = np.max(no3)
for ds in histdss:
    ds0111 = ds.where( (histds['year'] > 2000) & (histds['year'] < 2002), drop=True)
    modno3 = mg_per_g*ds0111['SMIN_NO3_vr'].mean(axis=0).isel(lndgrid=0).values*m3_per_cm3
    # Prevent pure zeros to allow log scaling
    modno3       = modno3[mod_depth>=np.min(no3_depth)]
    modno3_depth = mod_depth[mod_depth>=np.min(no3_depth)]
    modno3 = np.where(modno3 < 1e-20, false_zero, modno3)
    min_no3 = np.min([min_no3,np.min(modno3)])
    max_no3 = np.max([max_no3,np.max(modno3)])
    ax2.scatter(modno3,modno3_depth,label='elm-fates',s=50,marker='+')
  
ax2.set_xlabel('NO3+ Content [mg/cm3]')
ax2.set_yticklabels([])
ax2.set_ylim([1.1*np.min(no3_depth),0.0])
if (np.min(no3)>1.e-20):
    ax2.set_xscale('log')
    ax2.set_xlim([0.01*min_no3,10.*max_no3])
else:
    ax2.set_xlim([0,ax2.get_xlim()[1]])

po4 = np.where(np.array(po4) < 1e-20, false_zero, po4)    
min_solp = np.min(po4);max_solp = np.max(po4)
ax3.scatter(po4,po4_depth,s=50,marker='o')
for ds in histdss:
    ds0111 = ds.where( (histds['year'] > 2000) & (histds['year'] < 2002), drop=True)
    modsolp = mg_per_g*ds0111['SOLUTIONP_vr'].mean(axis=0).isel(lndgrid=0).values*m3_per_cm3
    # Prevent pure zeros to allow log scaling
    modsolp       = modsolp[mod_depth>=np.min(po4_depth)]
    modsolp_depth = mod_depth[mod_depth>=np.min(po4_depth)]
    modsolp = np.where(modsolp < 1e-20, false_zero, modsolp)
    min_solp = np.min([min_solp,np.min(modsolp)])
    max_solp = np.max([max_solp,np.max(modsolp)])
    ax3.scatter(modsolp,modsolp_depth,label='elm-fates',s=50,marker='+')

print(min_solp,max_solp)    
    
ax3.set_xlabel('P Solution Content [mg/cm3]')
ax3.set_yticklabels([])
ax3.set_ylim([1.1*np.min(po4_depth),0.0])
if (np.min(po4)>1.e-20):
    ax3.set_xscale('log')
    ax3.set_xlim([0.01*min_solp,10.*max_solp])
else:
    ax3.set_xlim([0,ax3.get_xlim()[1]])

ax1.grid("on");ax2.grid("on");ax3.grid("on");
plt.show()
#plt.savefig('mineralized_compare.png')

#files.download('mineralized_compare.png')

"""Mineralized nutrient concentrations in soils at BCNM. Measurements published in Yavitt and Wright 2001, are taken on Barro Colorado Island February 1990."""